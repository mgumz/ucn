//go:build ignore

// this code generates html_entities.go
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
	"slices"
	"strings"
	"unicode"
	"unicode/utf8"
)

const (
	entitiesURL = "https://html.spec.whatwg.org/entities.json"
)

// {
//  "&AElig": { "codepoints": [198], "characters": "\u00C6" },
//  "&AElig;": { "codepoints": [198], "characters": "\u00C6" },

type EntityList map[string]struct {
	CPs   []int  `json:"codepoints"`
	Chars string `json:"characters"`
}

func main() {

	ofile := flag.String("out", "", "output file")
	flag.Parse()

	owriter := os.Stdout
	if *ofile != "" {
		var err error
		if owriter, err = os.Create(*ofile); err != nil {
			fmt.Fprintf(os.Stderr, "error: creating file %q: %s\n", *ofile, err)
			os.Exit(13)
		}
	}

	resp, err := http.Get(entitiesURL)
	if err != nil {
		fmt.Fprintln(os.Stderr, "error fetching", entitiesURL, ":", err)
		os.Exit(1)
		return
	}

	defer resp.Body.Close()

	entities := EntityList{}
	dec := json.NewDecoder(resp.Body)
	if err = dec.Decode(&entities); err != nil {
		fmt.Fprintln(os.Stderr, "error decoding", entitiesURL, ":", err)
		os.Exit(2)
		return
	}

	rmap := map[rune]string{}

	for e, v := range entities {
		// we have "&AMP" and "&AMP;", lets only use "&AMP;"
		if !strings.HasSuffix(e, ";") {
			continue
		}

		r, s := utf8.DecodeRuneInString(v.Chars)
		// we also skip all entries with multiples runes
		if s != len(v.Chars) {
			continue
		}

		// we want to prefer lower-case entities over Upper-Case ones
		// (&amp; trumps &AMP;)
		me, exists := rmap[r]
		if exists {
			r2, _ := utf8.DecodeRuneInString(me[1:])
			if unicode.IsUpper(r2) {
				continue
			}
		}

		rmap[r] = e
	}

	// prepare stable output order
	rorder := make([]rune, 0, len(rmap))
	for r := range rmap {
		rorder = append(rorder, r)
	}
	slices.Sort(rorder)

	fmt.Fprintf(owriter, `// code generated by go generate; DO NOT EDIT.

package print

// based upon %q
var rune2entity = map[rune]string {
`, entitiesURL)
	for _, r := range rorder {
		fmt.Fprintf(owriter, "	%d: %q,\n", r, rmap[r])
	}
	fmt.Fprintln(owriter, "}")
}
